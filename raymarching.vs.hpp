/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef RAYMARCHING_VS_HPP_
# define RAYMARCHING_VS_HPP_

const char *raymarching_vs =
 "#version 330\n"
 "float s(float f,float v)"
 "{"
   "float s=v/4.*60.,n=15.,r=.8;"
   "return smoothstep(-n/2.,-n*(1.-r)/2.,-abs(f-s-n*.5));"
 "}"
 "vec3 s(float v)"
 "{"
   "float f=v+2.;"
   "vec3 n=vec3(f,f*f,f*f*f),r=fract(n*222.)+vec3(2.);"
   "return fract(n*r.yzx*r.zxy);"
 "}"
 "float v(float v)"
 "{"
   "return v/44100;"
 "}"
 "float f(float v)"
 "{"
   "return 1.-smoothstep(0.,4.,v);"
 "}"
 "float i(float v)"
 "{"
   "float f=60.-v;"
   "return 1.-smoothstep(0.,4.,f);"
 "}"
 "mat3 f(vec3 f,vec3 v)"
 "{"
   "vec3 n=normalize(f-v),r=normalize(cross(vec3(0.,1.,0.),n)),D=normalize(cross(n,r));"
   "mat3 s=mat3(r,D,n);"
   "return s;"
 "}"
 "uniform bool is_shadowmap;"
 "const mat4 n=mat4(1./1.5,0.,0.,0.,0.,1./1.5,0.,0.,0.,0.,-.4,0.,0.,0.,-1.4,1.);"
 "vec3 f()"
 "{"
   "return vec3(1.5,3.,2.);"
 "}"
 "mat3 i()"
 "{"
   "return f(f(),vec3(0.));"
 "}"
 "vec3 m(float v)"
 "{"
   "return is_shadowmap?f():vec3(.3,2.+cos(v),3.+sin(v)*.8);"
 "}"
 "mat3 i(float v,vec3 n)"
 "{"
   "return is_shadowmap?i():f(n,vec3(0.));"
 "}"
 "uniform float sample_count;"
 "out vec3 vary_ray_dir;"
 "void main()"
 "{"
   "if(gl_VertexID==0)"
     "gl_Position=vec4(-1.,-1.,.999,1.);"
   "else"
     " if(gl_VertexID==1)"
       "gl_Position=vec4(3.,-1.,.999,1.);"
     "else"
       " gl_Position=vec4(-1.,3.,.999,1.);"
   "float f=v(sample_count);"
   "vec3 n=m(f);"
   "mat3 s=i(f,n);"
   "if(is_shadowmap)"
     "vary_ray_dir=s[0]*gl_Position.x*1.5+s[1]*gl_Position.y*1.5-s[2]+n;"
   "else"
     " vary_ray_dir=s[0]*gl_Position.x*.05+s[1]*gl_Position.y*1080./1920.*.05-s[2]*.1;"
 "}";

#endif // RAYMARCHING_VS_HPP_
